{"ast":null,"code":"var _jsxFileName = \"/home/lenix/PycharmProjects/GBC/frontend/src/components/AppMenu/FileBtn.js\";\nimport React, { Component } from 'react';\nimport { fileIcon } from './InnerTree';\nimport { connect } from \"react-redux\";\nimport { setComponentName } from \"../../store/currentComponent/actions\"; // FileBtn – компонент-кнопка, отображающая название файла на боковой панели\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass FileBtn extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      isFocused: false\n    };\n\n    this.displayComponent = () => {\n      const {\n        setComponentName,\n        file,\n        isUserComponent,\n        dir\n      } = this.props;\n      const fileName = file.slice(0, -3);\n\n      if (isUserComponent) {\n        setComponentName(dir, isUserComponent, fileName);\n      } else {\n        setComponentName(fileName, isUserComponent, \"\");\n      } // присвоить компоненту фокус, если он отображается, и наоборот\n\n\n      this.setState({\n        isFocused: !this.isFocused()\n      });\n    };\n\n    this.eliminate = () => {\n      this.setState({\n        isFocused: !this.isFocused()\n      });\n    };\n\n    this.isFocused = () => {\n      return this.state.isFocused;\n    };\n  }\n\n  // метод, вызывающийся перед рендером компонента\n  // метод позволяет отследить изменение фокуса на компоненте\n  static getDerivedStateFromProps(props, state) {\n    const {\n      componentName,\n      file\n    } = props;\n    const fileName = file.slice(0, -3);\n    const isEqual = componentName === fileName; // если кнопка в фокусе,\n    // но ее название не совпадает с названием прожатой в данный момент кнопки,\n    // то фокус нужно снять, и наоборот\n\n    if (state.isFocused && !isEqual) {\n      return {\n        isFocused: false\n      };\n    } else if (!state.isFocused && isEqual) {\n      return {\n        isFocused: true\n      };\n    } // в ином случае оставить без изменений\n\n\n    return null;\n  }\n\n  render() {\n    const condition = this.isFocused() ? 'active' : 'disabled';\n    return /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"tree-element__file\",\n      onClick: this.displayComponent,\n      onMouseOver: this.eliminate,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: `tree-element__highlighter tree-element__highlighter_${condition}`\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 17\n      }, this), fileIcon, /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"tree-element__wrapper\",\n        children: this.props.file\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 41,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 13\n    }, this);\n  } // метод вызывает колбэк, отображающий компонент или прячущий его\n\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    componentName: state.currentComponent.componentName\n  };\n};\n\nconst mapDispatchToProps = {\n  setComponentName\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(FileBtn);","map":{"version":3,"sources":["/home/lenix/PycharmProjects/GBC/frontend/src/components/AppMenu/FileBtn.js"],"names":["React","Component","fileIcon","connect","setComponentName","FileBtn","state","isFocused","displayComponent","file","isUserComponent","dir","props","fileName","slice","setState","eliminate","getDerivedStateFromProps","componentName","isEqual","render","condition","mapStateToProps","currentComponent","mapDispatchToProps"],"mappings":"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","sourcesContent":["import React, {Component} from 'react'\nimport { fileIcon } from './InnerTree'\nimport {connect} from \"react-redux\";\nimport {setComponentName} from \"../../store/currentComponent/actions\";\n\n// FileBtn – компонент-кнопка, отображающая название файла на боковой панели\nclass FileBtn extends Component {\n    state = {\n        isFocused: false\n    }\n\n    // метод, вызывающийся перед рендером компонента\n    // метод позволяет отследить изменение фокуса на компоненте\n    static getDerivedStateFromProps(props, state) {\n        const { componentName, file } = props;\n        const fileName = file.slice(0, -3);\n        const isEqual = componentName === fileName;\n\n        // если кнопка в фокусе,\n        // но ее название не совпадает с названием прожатой в данный момент кнопки,\n        // то фокус нужно снять, и наоборот\n        if (state.isFocused && !isEqual) {\n            return { isFocused: false }\n        } else if (!state.isFocused && isEqual) {\n            return { isFocused: true }\n        }\n\n        // в ином случае оставить без изменений\n        return null;\n    }\n\n    render() {\n        const condition = this.isFocused() ? 'active' : 'disabled';\n\n        return (\n            <button className=\"tree-element__file\"\n                    onClick={ this.displayComponent }\n                    onMouseOver={ this.eliminate }>\n                <div className={`tree-element__highlighter tree-element__highlighter_${condition}`}/>\n                    {fileIcon}\n                <div className=\"tree-element__wrapper\">\n                    {this.props.file}\n                </div>\n            </button>\n        )\n    }\n\n    // метод вызывает колбэк, отображающий компонент или прячущий его\n    displayComponent = () => {\n        const { setComponentName, file, isUserComponent, dir } = this.props;\n        const fileName = file.slice(0, -3);\n\n        if (isUserComponent) {\n            setComponentName(dir, isUserComponent, fileName)\n        } else {\n            setComponentName(fileName, isUserComponent, \"\");\n        }\n\n        // присвоить компоненту фокус, если он отображается, и наоборот\n        this.setState({\n            isFocused: !this.isFocused()\n        })\n    }\n\n    // подсвечивает компонент при наведении мыши\n    eliminate = () => {\n        this.setState({\n            isFocused: !this.isFocused()\n        })\n    }\n\n    isFocused = () => {\n        return this.state.isFocused;\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        componentName: state.currentComponent.componentName\n    }\n}\n\nconst mapDispatchToProps = {\n    setComponentName\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(FileBtn);"]},"metadata":{},"sourceType":"module"}